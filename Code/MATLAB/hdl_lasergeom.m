function Calib = hdl_lasergeom(Db)
%HDL_LASERGEOM precaches HDL-64E point cloud geometry.
%   CALIB = HDL_LASERGEOM(DB) returns a CALIB data structure based upon the
%   calibration information contained in the DB data structure from
%   HDL_LOADDB.
%
%   The main idea is to pre-compute unit vectors in the sensor frame for all
%   36000 yaw angles and all 64 lasers. Thus, given the raw range data, an
%   XYZ point cloud in the sensor frame can be simply generated by scaling
%   the direction vectors by measured range and adding an offset.
%
%   (c) 2006 Ryan M. Eustice
%            University of Michigan
%            eustice@umich.edu
%  
%-----------------------------------------------------------------
%    History:
%    Date            Who          What
%    -----------     -------      -----------------------------
%    12-09-2006      RME          Created and written.
%    01-31-2007      JS           Changed to accomodate 64 lasers.
%    02-01-2007      RME          Removed firingOrder fields.
%    02-19-2007      RME          Redefined sensor frame convention to
%                                 match that of DSR, (i.e., Ys-axis aligned
%                                 with zero yaw degree).
%    02-19-2007      RME          Added Calib.xo,Calib.yo,Calib.zo
%                                 correction factors, to compensate for
%                                 parallax effects
%    07-13-2007      RME          Changed yawInd to span 0:36000 instead of
%                                 1:36000 to accomodate fact that new Velodyne
%                                 firmware reports yaw encoder from 0:35999
%                                 while old firmware reported from 1:36000.
%                                 yawInd = Scan.Data.yawc + 1; should now work.
%    07-13-2007      RME          Changed Calib struct to convert to [m] instead of [cm]

if(exist('dist_rot_correction_with_UB_LB.mat','file'))
    load dist_rot_correction_with_UB_LB.mat
    Db.distCorrection = distCorrection*100;
    Db.rotCorrection = rotCorrection;
    fprintf(1,'Updating rotation and distance correction');
else
    fprintf(1,'rotation and distance correction does not exist');
end

DTOR = pi/180;
uprBlk = int32(1:32)';
lwrBlk = int32(33:64)';
% the x,y,z data points are organized in an [nL x nY] array where
% nY = # of possible yaw angles and nL = # of lasers.
Calib.x_vs = [Db.xyz/100, Db.rpy*DTOR]';
Calib.distLSB = Db.distLSB/100; % [m/count]
Calib.distCorrection = reshape(Db.distCorrection/100,[],1); % [nL 1]
Calib.laserID = reshape(Db.id,[],1); % [nL 1]
Calib.yawInd =  (0:36000);           % [1 nY]
nY = length(Calib.yawInd);
nL = length(Calib.laserID);

% Coordinate Reconstruction
% upper Blk: Dxy = (D+deltaD)cos(theta) - 2.85cos(theta) ; Z = Voffset + (D+deltaD)sin(theta) - 2.85sin(theta) 
% lower Blk: Dxy = (D+deltaD)cos(theta) - 1.8cos(theta)  ; Z = Voffset + (D+deltaD)sin(theta) - 1.8sin(theta) 
% X = Dxy*sin(alpha) - Hoffset*cos(alpha)
% Y = Dxy*cos(alpha) + Hoffset*sin(alpha)
% alpha = rotationAngle - rotCorrection 
% Voffset(uprBlk) = 8.1328*2.54/100 + z1 
% Voffset(lwrBlk) = 5.2815*2.54/100 + z2
% z1 = (2.8309*2.54/100).*tan(theta(uprBlk))
% z2 = (2.4464*2.54/100).*tan(theta(lwrBlk))

% Defn: Sensor Frame
%    ^ Ys  Ys-axis aligned with yaw=0 degrees
%    |
%    |
% Zs o-------> Xs

% yaw angle to Ys'-axis
psi = (0:0.01:360) * DTOR; % [1 nY]
psi = repmat(psi,[nL 1]);  % [nL nY]

% rotCorrection from Ys'-axis
phi = reshape(Db.rotCorrection,[],1) * DTOR; % [nL 1]
phi = repmat(phi,[1 nY]);                    % [nL nY]

% vertCorrection from Xs-Ys plane
theta = reshape(Db.vertCorrection,[],1) * DTOR; % [nL 1]
theta = repmat(theta,[1 nY]);                   % [nL nY]

% resulting yaw angle to laser
alpha = psi-phi; % [nL nY]

% vertOffsetCorrection (From new doc : upperBlk = 8.1328 inch, lowerBlk = 5.2815 inch)
% 1 inch = 2.54 cm;
horizDistLens2CenterUB = 2.8309*2.54/100;
horizDistLens2CenterLB = 2.4464*2.54/100;
cv = reshape(Db.vertOffsetCorrection/100,[],1);  % [nL 1]
z1 = horizDistLens2CenterUB.*tan(theta(uprBlk));
z2 = horizDistLens2CenterLB.*tan(theta(lwrBlk));
cv(uprBlk) = cv(uprBlk) + z1; 
cv(lwrBlk) = cv(lwrBlk) + z2;
cv = repmat(cv,[1 nY]);                          % [nL nY]

% rangeCorrection (From new doc : upperBlk = 2.85 inch, lowerBlk = 1.8 inch)
% rc = reshape(Db.rangeCorrection/100,[],1); %[nL,1]
% ideally this value should come from the xml file
rc = ones(nL,1);
rcUB = (2.85*2.54/100);
rcLB = (1.8*2.54/100);
rc(uprBlk) = rcUB.*rc(uprBlk);
rc(lwrBlk) = rcLB.*rc(lwrBlk);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
rc = repmat(rc,[1,nY]); %[nL nY];

% horizOffsetCorrection
ch = reshape(Db.horizOffsetCorrection/100,[],1); % [nL 1]
ch = repmat(ch,[1 nY]);                          % [nl nY]

% azimuth-elevation pointing vector on unit sphere
Calib.xhat = cos(theta).*sin(alpha); % [nL nY]
Calib.yhat = cos(theta).*cos(alpha); % [nL nY]
Calib.zhat = sin(theta);             % [nL nY]

% offset correction that must be added to pointing vector
% Calib.xo = cv.*(-sin(theta).*sin(alpha)) + ch.*(-cos(alpha)); % [nL nY]
% Calib.yo = cv.*(-sin(theta).*cos(alpha)) + ch.*(sin(alpha));  % [nL nY]
% Calib.zo = cv.*cos(theta);                                    % [nL nY]
Calib.xo = rc.*(-cos(theta).*sin(alpha)) + ch.*(-cos(alpha)); % [nL nY]
Calib.yo = rc.*(-cos(theta).*cos(alpha)) + ch.*(sin(alpha));  % [nL nY]
Calib.zo = rc.*(-sin(theta)) + cv;                               % [nL nY]
